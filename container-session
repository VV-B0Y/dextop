#!/bin/bash

# dependencies #

. "${PREFIX}"/bin/console

# script #

script=$(basename -- "${BASH_SOURCE[0]}")

# version #

version="12-03-2021"

# usage #

while (($#))
do
	case "${1}"
	in
		-o|--start)
			option="start"
		;;

		-x|--stop)
			option="stop"
		;;

		-p|--password)
			option="password"
		;;

		-c|--clean)
			option="clean"
		;;

		-n|--new)
			option="new"
		;;

		-u|--username)
			option="username"
			user_name="${2}"

			shift
		;;

		-h|--help)
			echo
			echo -e "Usage: ${script} -u [User Name] | [OPTION]"
			echo
			echo -e "Options:"
			echo
			echo -e "-o, --start       Start vnc session server."
			echo -e "-x, --stop        Stop vnc session server."
			echo -e "-p, --password    Generate vnc session password."
			echo
			echo -e "-c, --clean       Generate new vnc session selection."
			echo -e "-n, --new         Generate new vnc session selection."
			echo
			echo -e "-u, --username    Specify 'user' for session login."
			echo
			echo -e "-h, --help        Show help and usage information."
			echo
			echo -e "'${script}' [ Version ${version} ]"
			echo

			exit
		;;

			"")
				# handle empty argument:
				# use default values specified in script

				:
			;;

		*)
			echo
			echo -e "Usage: ${script} -u [User Name] | [OPTION]"
			echo
			echo -e "${script}: Unknown option '${1}'"
			echo -e "Type './${script} --help' for help and usage information."
			echo

			exit 1
		;;

	esac

	shift
done

# prompt #

console.script "Setting up ${script#*-}"
echo

# variables #

# defaults #

[ -z "${DISPLAY}" ]         && DISPLAY=":1"
[ -z "${DISPLAY_NUMBER}" ]  && DISPLAY_NUMBER="${DISPLAY/:/}"
[ -z "${LOCALHOST}" ]       && LOCALHOST="127.0.0.1"
[ -z "${ADDRESS}" ]         && ADDRESS="${LOCALHOST}"
[ -z "${PORT}" ]            && PORT="590${DISPLAY_NUMBER}"

export DISPLAY="${DISPLAY}"

[ -f /etc/os-release ] && . /etc/os-release && name="${NAME}" || name=Ubuntu

# functions #

vnc_clean () {
	[ -d "${HOME}" ]   && rm -rf "${HOME}"/.ICE*
	[ -d "${HOME}" ]   && rm -rf "${HOME}"/.X1*
	[ -d "${HOME}" ]   && rm -rf "${HOME}"/.Xauth*
	[ -d "${TMPDIR}" ] && rm -rf "${TMPDIR}"/.ICE*
	[ -d "${TMPDIR}" ] && rm -rf "${TMPDIR}"/.X1*
	[ -d "${TMPDIR}" ] && rm -rf "${TMPDIR}"/.Xauth*
}

vnc_geometry () {
	console.msg "Select geometry to start the display server"
	console.msg "or input [c]ustom properties:"
	echo

	# list supported display resolutions

	monitors=(
		VGA		 0640    0480
		WVGA	 0768    0480
		SVGA	 0800    0600
		FWVGA	 0854    0480
		qHD		 0960    0540
		DVGA	 0960    0640
		WSVGA	 1024    0576
		WSVGA	 1024    0600
		XGA		 1024    0768
		XGA+	 1152    0864
		HD		 1280    0720
		WXGA	 1366    0768
		WXGA+	 1440    0900
		HD+		 1600    0900

		SXGA	 1280    1024
		SXGA+	 1400    1050
		UXGA	 1600    1200
		WSXGA+	 1680    1050
		FHD		 1920    1080
		WUXGA	 1920    1200
		DCI2K	 2048    1080
		QWXGA	 2048    1152
		QXGA	 2048    1536
		UWFHD	 2560    1080
		QHD		 2560    1440
		WQXGA	 2560    1600
		QSXGA	 2560    2048
		QHD+	 3200    1800
		WQSXGA	 3200    2048
		QUXGA	 3200    2400
		UWQHD	 3440    1440
		UW4K	 3840    1600
		4KUHD	 3840    2160
		WQUXGA	 3840    2400
		DCI4K	 4096    2160
		UW5K	 5120    2160
		5K		 5120    2880
		8KUHD	 7680    4320
	)

	phones=(
		GN6P	 2560    1440
		GN6		 2560    1440
		GN5X	 1920    1080
		GN5		 1920    1080
		GP5		 2340    1080
		GP4XL	 3040    1440
		GP4a	 2340    1080
		GP4		 2280    1080
		GP3aXL	 2160    1080
		GP3a	 2220    1080
		GP3XL	 2960    1440
		GP3		 2160    1080
		GP2XL	 2880    1440
		GP2		 1920    1080
		GPXL	 2560    1440
		GP		 1920    1080

		SGN20+	 3088    1440
		SGN20	 3200    1440
		SGN10+	 3040    1440
		SGN10	 2280    1080
		SGN9	 2960    1440
		SGN8	 2960    1440
		SGN7	 2560    1440

		SGS10+	 3040    1440
		SGS10	 3040    1440
		SGS9+	 2960    1440
		SGS9	 2960    1440
		SGS8+	 2960    1440
		SGS8	 2960    1440
		SGS7E	 2560    1440
		SGS7	 2560    1440
		SGS6E+	 2560    1440
		SGS6E	 2560    1440
		SGS6	 2560    1440
	)

	tablets=(
		GN9	     2048    1536
		GN7-2013 1920    1200
		GPC	     2560    1800

		SGTS7+	 2800    1752
		SGTS7	 2560    1600
		SGTS6	 2560    1600
		SGTS5E	 2560    1600
		)

	devices=(
		${phones[@]}
		${tablets[@]}
	)

	geometries=(
		${monitors[@]}
		${devices[@]}
	)

	# set padding for uniform output

	pad_length=10

	# continue list using array selection of suppported values

	for (( i=0 ; i<${#geometries[@]} ; i+=3 ))
	do
		format="${geometries[$i]}"
		width="${geometries[$i+1]}"
		height="${geometries[$i+2]}"
		geometry="${width}x${height}"

		number=$((($i/3) + 1))

		if (( $i/3 >= 0 && $i/3 <= 8 ))
		then
			# handle number spacing for entries 1-9

			printf '      [  %s ] %s' ${number} ${format}
		else
			# handle number spacing for entries 10+

			printf '      [ %s ] %s' ${number} ${format}
		fi

		printf '%*s' $((pad_length - ${#format}))
		printf '%s\n' ${geometry}
	done

	printf '\n'
}

vnc_intent () {
	console.fwd "Opening display..."
	echo

	# explicit VNC viewer application to kill:
	# used when vncserver is stopped or restarted using vnc:// intent
	# when launched via the activity manager [ 'am start -d {URI} -S {ACTIVITY}' ]

	# reference vnc session activity for known applications:

	# FreebVNC: com.iiordanov.freebVNC/com.iiordanov.bVNC.RemoteCanvasActivity
	# RealVNC:  com.realvnc.viewer.android/.app.DesktopActivity
	# Remotix:  com.nulana.android.remotix/.Viewer

	# start android vnc intent and force-stop existing activity

	# console.silence "am start -a android.intent.action.VIEW -d vnc://${ADDRESS}:${PORT} -S ${VNC}"

	# start android vnc intent and set to view session with supported application

	unset intent_command

	intent_command+="am start"
	intent_command+=" -a android.intent.action.VIEW"
	intent_command+=" -d vnc://${ADDRESS}:${PORT}"

	console.silence "exec ${intent_command}"
}

vnc_start () {
	console.fwd "Starting display server..."
	echo

	depth="32"
	security="none"
	timeout="0"
	xstartup="$(echo $(command -v startxfce4 &))"

	# Notes:
	# 'vncserver' uses $DISPLAY instead of $PORT
	# use 'Xvnc' to ensure proper parameter application

	unset command_start

	command_start+="vncserver"
	command_start+=" -xstartup ${xstartup}"
	command_start+=" -SecurityTypes ${security}"
	command_start+=" -IdleTimeout ${timeout}"
	command_start+=" -depth ${depth}"
	command_start+=" -geometry ${geometry}"
	command_start+=" -desktop ${name}"
	command_start+=" -nolock"
	command_start+=" ${DISPLAY}"

	console.silence "exec ${command_start}"

	# make selection available for automatic start:
	# verify user id - do not write selection when 'root' user is logged in

	if [[ $(id -u -n) = "root" ]]
	then
		:
	else
		# integer check:
		# do not write non numerical values to file

		if [[ "${selection}" =~ ^[0-9]+$ ]]
		then
			echo "${selection}" > "${HOME}"/.vnc/selection
		fi
	fi

	vnc_intent
}

vnc_stop () {
	unset command_stop

	command_stop+="vncserver"
	command_stop+=" -kill ${DISPLAY}"

	console.silence "exec ${command_stop}" &

	console.progress "Killing display server..."
	echo

	# clean display server runtime files

	vnc_clean
}

vnc_list () {
	# get values from 'vncserver -list'

	vnc_port="${PORT}"

	if [[ $(ps -A | grep -i proot) ]]
	then
		read vnc_display _ vnc_process _ <<< $(vncserver -list | tail -n 1)
	else
		read vnc_display vnc_process <<< $(vncserver -list | tail -n 1)
	fi

	# integer check:
	# set values for list output

	if [[ "${vnc_process}" =~ ^[0-9]+$ ]]
	then
		console.fwd "Listing servers..."
		echo

		vnc_display="${vnc_display}"
		vnc_port="${vnc_port}"
		vnc_process="${vnc_process}"
	else
		console.wrn "No active servers detected."
		echo

		empty="N/A"

		geometry="${empty}"
		format="${empty}"

		vnc_display="${empty}"
		vnc_port="${empty}"
		vnc_process="${empty}"
	fi

	console.inf "Geometry" "[ ${geometry} ]"
	console.inf "Format"   "[ ${format} ]"
	console.inf "Display"  "[ ${vnc_display} ]"
	console.inf "Port"     "[ ${vnc_port} ]"
	console.inf "Process"  "[ ${vnc_process} ]"
	echo
}

vnc_pass () {

	# values #

	values_list=(
		vnc_password
	)

	# handle user input for values_list

	console_rtn=()

	console.input ${values_list[@]}

	eval ${console_rtn[@]}

	# hash password  using 'vncpasswd' and store it

	console.fwd "Setting password..."
	echo

	echo "$vnc_password" | vncpasswd -f > "${HOME}"/.vnc/passwd

	console.scs "Password changed."
	echo
}

vnc_handle () {
	# values #

	values_list=(
		selection
	)

	# handle user input for values_list

	console_rtn=()

	if [ -f "${HOME}"/.vnc/selection ]
	then
		selection=$(cat "${HOME}"/.vnc/selection)
	else
		console.input ${values_list[@]}
	fi

	eval ${console_rtn[@]}

	# check selection input against selection list

	while true
	do
		# range #

		if [[ "${selection}" -lt 1 ]] || [[ "${selection}" -gt "${number}" ]]
		then
			echo
			console.err "Invalid selection:"
			console.wrn "Select geometry ranging from [ 1 - ${number} ]"
			console.wrn "or input [c]ustom properties."
			echo

			console.ipt "Selection:"

			read selection
			echo
		else
			break
		fi

		# custom #

		if [[ "${selection}" != "c" ]]
		then
			echo
			console.err "Invalid selection:"
			console.wrn "Input [c]ustom properties"
			console.wrn "or select geometry ranging from [ 1 - ${number} ]."
			echo

			console.ipt "Selection:"

			read selection
			echo
		else
			selection=custom

			break
		fi

	done

	unset geometry

	# integer check:
	# handle numerical selection

	if [[ "${selection}" =~ ^[0-9]+$ ]]
	then
		i=$((${selection}))
		i=$(($i*3))

		format="${geometries[$i-3]}"
		width="${geometries[$i-2]}"
		height="${geometries[$i-1]}"
		geometry="${width}x${height}"

	fi

	# handle custom selection

	if [[ "${selection}" = "custom" ]]
	then
		console.fwd "Setting custom properties..."
		echo

		console.ipt "WIDTH" "[ pixels ]"

		read width
		echo

		console.ipt "HEIGHT" "[ pixels ]"

		read height
		echo

		console.ipt "DISPLAY" "[ e.g. 1 ]"

		read display
		echo

		format="Custom"
		geometry="${width}x${height}"

		DISPLAY=":${display}"
		DISPLAY_NUMBER="${DISPLAY/:/}"
		PORT="590${DISPLAY_NUMBER}"
	fi
}

container_user () {
	# verify user existence:
	# loop through container's /etc/passwd and make sure 'user' exists
	# and corresponds to 'username' then source environment variables from file
	# default to 'root' if 'username' is invalid, not specified or does not exist

	last_entry="$(tail -n 1 "${PREFIX}"/cnt/etc/passwd)"

	# authentication #

	console.fwd "Authenticating..."
	echo

	while read -r entry
	do
		IFS=':'

		read USER _ USER_ID GROUP_ID GECOS HOME SHELL <<< "${entry}"

		IFS=','

		read FULL_NAME ROOM_NUMBER WORK_PHONE HOME_PHONE USER_EMAIL <<< "${GECOS}"

		# reset IFS

		IFS=' '

		# messages:
		# verify login options and parameters

		if [[ -z "${user_name}" ]]
		then
			user_name="root"

			console.wrn "No user name - Defaulting" "[ '${user_name}' ]"
			echo

			# break out of loop - empty "${user_name}" - default to 'root'

			break
		fi

		if [[ "${user_name}" == "${USER}" ]]
		then
			user_name="${USER}"

			console.scs "Valid user name" "[ '${user_name}' ]"
			echo

			# break out of loop - matching "${user_name}"

			break
		fi

		if [[ "${entry}" == "${last_entry}" ]]
		then
			user_name="root"

			console.err "Invalid user name - Defaulting" "[ '${user_name}' ]"
			echo
		fi

		# specify login defaults

		if [[ -z "${user_name}" ]] || [[ "${entry}" == "${last_entry}" ]]
		then
			USER="root"
			USER_ID=0
			GROUP_ID=0
			FULL_NAME="root"
			HOME="/root"
			session_name="CONSOLE"
			SHELL="/bin/bash"
		fi

	done < "${PREFIX}"/cnt/etc/passwd
}

container_session () {
	container_user

	# system #

	# explicit 'proot' command setup defaults:
	# used to specify the desktop session:
	# login format / environment /pathnv'

	# set path:
	# in order of retreival

	PATH=""

	# container

	[ -d "${PREFIX}"/cnt/usr/local/sbin ]											&& PATH+="/usr/local/sbin:"
	[ -d "${PREFIX}"/cnt/usr/local/bin ]											&& PATH+="/usr/local/bin:"
	[ -d "${PREFIX}"/cnt/usr/sbin ]													&& PATH+="/usr/sbin:"
	[ -d "${PREFIX}"/cnt/usr/sbin ]													&& PATH+="/usr/bin:"
	[ -d "${PREFIX}"/cnt/sbin ]														&& PATH+="/sbin:"
	[ -d "${PREFIX}"/cnt/bin ]														&& PATH+="/bin:"

	# termux

	[ -d "${PREFIX}"/sbin ]															&& PATH+="${PREFIX}/sbin:"
	[ -d "${PREFIX}"/bin ]															&& PATH+="${PREFIX}/bin:"

	# android

	[ -d /system/sbin ]																&& PATH+="/system/sbin:"
	[ -d /system/bin ]																&& PATH+="/system/bin:"

	PATH="${PATH}"

	# set environment

	COLORTERM="truecolor"
	DISPLAY=":1"
	LANG="C.UTF-8"
	LOCALHOST="127.0.0.1"
	SHELL="/bin/bash"

	# xfce #

	[[ $(cat "${PREFIX}"/bin/dextop) = xfce ]] && session_name="XFCE" || session_name="CONSOLE"

	# defaults #

	console.fwd "Starting session" "[ ${session_name} // ${user_name} ]"
	echo

	# assume 'termux-exec' is installed

	unset LD_PRELOAD

	# setup 'proot' command arguments

	unset session_command

	session_command+="proot"
	session_command+=" --kill-on-exit"
	session_command+=" --link2symlink"
	session_command+=" --rootfs=${PREFIX}/cnt"
	session_command+=" --change-id=${USER_ID}:${GROUP_ID}"
	session_command+=" --pwd=${HOME}"
	[ -d "/apex" ]                       && session_command+=" --bind=/apex:/apex"
	[ -d "/data" ]                       && session_command+=" --bind=/data:/data"
	[ -d "/dev" ]                        && session_command+=" --bind=/dev:/dev"
	[ -e "/dev/urandom" ]                && session_command+=" --bind=/dev/urandom:/dev/random"
	[ -e "/linkerconfig/ld.config.txt" ] && session_command+=" --bind=/linkerconfig/ld.config.txt:/linkerconfig/ld.config.txt"
	[ -f "/plat_property_contexts" ]     && session_command+=" --bind=/plat_property_contexts:/plat_property_contexts"
	[ -f "/property_contexts" ]          && session_command+=" --bind=/property_contexts:/property_contexts"
	[ -d "/proc" ]                       && session_command+=" --bind=/proc:/proc"
	[ -d "/proc/self/fd" ]               && session_command+=" --bind=/proc/self/fd:/dev/fd"
	[ -e "/proc/self/fd/0" ]             && session_command+=" --bind=/proc/self/fd/0:/dev/stdin"
	[ -e "/proc/self/fd/1" ]             && session_command+=" --bind=/proc/self/fd/1:/dev/stdout"
	[ -e "/proc/self/fd/2" ]             && session_command+=" --bind=/proc/self/fd/2:/dev/stderr"
	[ -d "/storage" ]                    && session_command+=" --bind=/storage:/storage"
	[ -d "/sys" ]                        && session_command+=" --bind=/sys:/sys"
	[ -d "/system" ]                     && session_command+=" --bind=/system:/system"
	[ -d "/vendor" ]                     && session_command+=" --bind=/vendor:/vendor"
	[ -d "${PREFIX%/*}"/home ]           && session_command+=" --bind=${PREFIX%/*}/home:/home/${USER}"
	[ -d "${PREFIX}"/storage/external ]  && session_command+=" --bind=${PREFIX}/storage/external:/media/external"
	[ -d "${PREFIX}"/storage/internal ]  && session_command+=" --bind=${PREFIX}/storage/internal:/media/internal"
	[ -d "${PREFIX}"/tmp ]               && session_command+=" --bind=${PREFIX}/tmp:/tmp"
	[ -x "${PREFIX}"/bin/htop ]          && session_command+=" --bind=${PREFIX}/bin/top:/usr/bin/htop"
	[ -x "${PREFIX}"/bin/kill ]          && session_command+=" --bind=${PREFIX}/bin/kill:/usr/bin/kill"
	[ -x "${PREFIX}"/bin/pgrep ]         && session_command+=" --bind=${PREFIX}/bin/pgrep:/usr/bin/pgrep"
	[ -x "${PREFIX}"/bin/pkill ]         && session_command+=" --bind=${PREFIX}/bin/pkill:/usr/bin/pkill"
	[ -x "${PREFIX}"/bin/ps ]            && session_command+=" --bind=${PREFIX}/bin/ps:/usr/bin/ps"
	[ -x "${PREFIX}"/bin/top ]           && session_command+=" --bind=${PREFIX}/bin/top:/usr/bin/top"
	session_command+=" env -i"
	session_command+=" ANDROID_ART_ROOT=${ANDROID_ART_ROOT}"
	session_command+=" ANDROID_DATA=${ANDROID_DATA}"
	session_command+=" ANDROID_I18N_ROOT=${ANDROID_I18N_ROOT}"
	session_command+=" ANDROID_ROOT=${ANDROID_ROOT}"
	session_command+=" ANDROID_RUNTIME_ROOT=${ANDROID_RUNTIME_ROOT}"
	session_command+=" ANDROID_TZDATA_ROOT=${ANDROID_TZDATA_ROOT}"
	session_command+=" BOOTCLASSPATH=${BOOTCLASSPATH}"
	session_command+=" DEX2OATBOOTCLASSPATH=${DEX2OATBOOTCLASSPATH}"
	session_command+=" PREFIX=${PREFIX}"
	session_command+=" COLORTERM=${COLORTERM}"
	session_command+=" DISPLAY=${DISPLAY}"
	session_command+=" HOME=${HOME}"
	session_command+=" LANG=${LANG}"
	session_command+=" LOCALHOST=${LOCALHOST}"
	session_command+=" PATH=${PATH}"
	session_command+=" SHELL=${SHELL}"
	session_command+=" TERM=${TERM}"
	session_command+=" TMPDIR=${TMPDIR}"
	session_command+=" USER=${USER}"
	session_command+=" XDG_RUNTIME_DIR=/run/user/${USER_ID}"
	session_command+=" XDG_CONFIG_DIRS=/etc/xdg"
	session_command+=" XDG_CACHE_HOME=${HOME}/.cache"
	session_command+=" XDG_CONFIG_HOME=${HOME}/.config"
	session_command+=" XDG_DATA_HOME=${HOME}/.local/share"
	session_command+=" XDG_STATE_HOME=${HOME}/.local/state"
	session_command+=" XDG_DATA_DIRS=/usr/local/share:/usr/share"
	session_command+=" XAUTHORITY=${XDG_RUNTIME_DIR}/Xauthority"
	session_command+=" ${SHELL} --login"

	# execute 'proot'

	exec ${session_command}
}

if [ "${option}" = "start" ]
then
	# handle selections display

	if [ -f "${HOME}"/.vnc/selection ]
	then
		# hide if selection file is present

		vnc_geometry > /dev/null 2>&1
	else
		# show if selection file is not present

		vnc_geometry
	fi

	vnc_handle

	# start vnc session

	vnc_start
fi

if [ "${option}" = "stop" ]
then
	# stop vnc session

	vnc_stop
fi

if [ "${option}" = "password" ]
then
	# generate password

	vnc_pass
fi

if [ "${option}" = "clean" ]
then
	# remove lock files and session handlers

	vnc_clean
fi

if [ "${option}" = "new" ]
then
	# handle selections display

	if [ -f "${HOME}"/.vnc/selection ]
	then
		# remove  if selection file is present

		rm -rf  "${HOME}"/.vnc/selection

		vnc_geometry
	fi

	vnc_handle

	# start vnc session

	vnc_start
fi

if [ "${option}" = "username" ]
then
	container_session
fi

# list vnc session

vnc_list
