#!/bin/bash

# dependencies /////////////////////////////////////////////////////////////////

if [[ -z $(command -v frobulator) ]]
then
	curl -s -L get.frbltr.app > "${PREFIX}"/bin/frobulator
fi

. "${PREFIX}"/bin/frobulator

# script ///////////////////////////////////////////////////////////////////////

script=$(basename -- "${BASH_SOURCE[0]}")

# version //////////////////////////////////////////////////////////////////////

version="01-21-2022"

# usage ////////////////////////////////////////////////////////////////////////

while (($#))
do
	case "${1}"
	in
		-o|--start)
			option="start"
		;;

		-x|--stop)
			option="stop"
		;;

		-p|--password)
			option="password"
		;;

		-c|--clean)
			option="clean"
		;;

		-n|--new)
			option="new"
		;;

		-v|--view)
			option="view"
		;;

		-a|--application)
			option="application"
			application="${2}"

			shift
		;;

		-u|--username)
			option="username"
			user_name="${2}"

			shift
		;;

		-r|--root)
			option="root"
			root_filesystem="${2}"

			shift
		;;

		-h|--help)
			echo
			echo -e "Usage: ${script} -u [User Name] | -a [Application] | [OPTION]"
			echo
			echo -e "Options:"
			echo
			echo -e "-o, --start          Start vnc session server."
			echo -e "-x, --stop           Stop vnc session server."
			echo -e "-p, --password       Generate vnc session password."
			echo
			echo -e "-c, --clean          Generate new vnc session selection."
			echo -e "-n, --new            Generate new vnc session selection."
			echo
			echo -e "-a, --application    Start application to start on session login."
			echo
			echo -e "-u, --username       Specify user name for session login."
			echo
			echo -e "-r, --root           Specify root filesystem directory."
			echo
			echo -e "-h, --help           Show help and usage information."
			echo
			echo -e "'${script}' [ Version // ${version} ]"
			echo

			exit
		;;

			"")
				# handle empty argument:
				# use default values specified in script

				:
			;;

		*)
			echo
			echo -e "Usage: ${script} -u [User Name] | -a [Application] | [OPTION]"
			echo
			echo -e "${script}: Unknown option '${1}'"
			echo -e "Type './${script} --help' for help and usage information."
			echo

			exit 1
		;;

	esac

	shift
done

# prompt ///////////////////////////////////////////////////////////////////////

frobulator.script "Setting up ${script#*-}"
echo

# variables ////////////////////////////////////////////////////////////////////

if [ "${HOME}" = "/	root" ]
then
	session_name="CONSOLE"
	:
else
	if [[ $(cat "${HOME}"/.dextop/dextop-option) = "xfce" ]]
	then
		session_name="XFCE"
	fi
fi

# defaults /////////////////////////////////////////////////////////////////////

if [ -z "${DISPLAY}" ]
then
	DISPLAY=":1"
fi

if [ -z "${DISPLAY_NUMBER}" ]
then
	DISPLAY_NUMBER="${DISPLAY/:/}"
fi

if [ -z "${LOCALHOST}" ]
then
	LOCALHOST="127.0.0.1"
fi

if [ -z "${ADDRESS}" ]
then
	ADDRESS="${LOCALHOST}"
fi

if [ -z "${PORT}" ]
then
	PORT="590${DISPLAY_NUMBER}"
fi

export DISPLAY="${DISPLAY}"

if [ -z "${COLORTERM}" ]
then
	COLORTERM="truecolor"
fi

if [ -z "${LANG}" ]
then
	LANG="C.UTF-8"
fi

if [ -z "${SHELL}" ]
then
	SHELL="/bin/bash"
fi

if [ -f /etc/os-release ]
then
	. /etc/os-release

	name="${NAME}"
fi

# functions ////////////////////////////////////////////////////////////////////

container_root () {
	# set container root directory

	ROOT=("${PREFIX}"/cnt/*/*)

	# single container

	if [[ ${#ROOT[@]} -eq 1 ]]
	then
		ROOT=("${PREFIX}"/cnt/*/*)
	fi

	# multiple containers:
	# parse container directories

	if [[ ${#ROOT[@]} -ge 2 ]]
	then
		for distribution in "${PREFIX}"/cnt/*
		do
			for version in "${distribution}"/*
			do
				distribution_name=$(basename $distribution)

				distribution_version=$(basename $version)

				containers+=($distribution_name $distribution_version)
			done
		done

		# set padding for uniform output

		pad_length=10

		# continue list using array selection of suppported values

		for (( i=0 ; i<${#containers[@]} ; i+=2 ))
		do
			name="${containers[$i]}"
			version="${containers[$i+1]}"
			container="${name} ${version}"

			number=$((($i/2) + 1))

			if (( $i/2 >= 0 && $i/2 <= 8 ))
			then
				# handle number spacing for entries 1-9

				printf '      [  %s ] %s ' ${number} ${name}
			else
				# handle number spacing for entries 10+

				printf '      [ %s ] %s ' ${number} ${name}
			fi

			printf '%*s' $((pad_length - ${#name}))
			printf '%s\n' ${version}
		done

		printf '\n'

		container_handle
	fi
}

container_handle () {
	# values #

	values_list=(
		selection
	)

	# handle user input for values_list

	frobulator_rtn=()

	if [ -f "${HOME}"/.dextop/selection ]
	then
		selection=$(cat "${HOME}"/.dextop/selection)
	else
		frobulator.input ${values_list[@]}
	fi

	eval ${frobulator_rtn[@]}

	# check selection input against selection list

	while true
	do
		# range check:
		# selection input must be in provided range and an integer

		if [[ "${selection}" -lt 1 ]] || [[ "${selection}" -gt "${number}" ]] || [[ ! "${selection}" =~ ^[0-9]+$ ]]
		then
			echo
			frobulator.err "Invalid selection:"
			echo

			frobulator.wrn "Select container [ 1 - ${number} ]"
			echo

			frobulator.ipt "Selection:"

			read selection
			echo
		else
			break
		fi
	done

	distribution_name="${name}"
	distribution_version="${version}"

	ROOT="${PREFIX}"/cnt/"${distribution_name}"/"${distribution_version}"
}

container_input () {
	if [ -d "${root_filesystem}" ]
	then
		ROOT="${root_filesystem}"

		frobulator.scs "Container location found"
		echo

		frobulator.inf "Loading" "[ ${ROOT} ]"
		echo
	else
		frobulator.err "Container location not found"
		echo

		frobulator.ipt "Select one of the following containers:"
		echo

		container_handle
	fi
}

container_environment () {
	# generate container environement

	# set path:
	# in order of retreival

	PATH=""

	# container

	[ -d "${ROOT}"/usr/local/sbin ] && PATH+="/usr/local/sbin:"
	[ -d "${ROOT}"/usr/local/bin ]  && PATH+="/usr/local/bin:"
	[ -d "${ROOT}"/usr/sbin ]       && PATH+="/usr/sbin:"
	[ -d "${ROOT}"/usr/sbin ]       && PATH+="/usr/bin:"
	[ -d "${ROOT}"/sbin ]           && PATH+="/sbin:"
	[ -d "${ROOT}"/bin ]            && PATH+="/bin:"

	# termux

	[ -d "${PREFIX}"/sbin ] && PATH+="${PREFIX}/sbin:"
	[ -d "${PREFIX}"/bin ]  && PATH+="${PREFIX}/bin:"

	# android

	[ -d /system/sbin ] && PATH+="/system/sbin:"
	[ -d /system/bin ]  && PATH+="/system/bin:"

	PATH="${PATH}"
}

container_user () {
	# verify user existence:
	# loop through container's /etc/passwd file and make sure 'user' exists
	# source environment variables when 'user' corresponds to 'username'
	# default to 'root' if 'username' is invalid, not specified or does not exist

	last_entry="$(tail -n 1 "${ROOT}"/etc/passwd)"

	# authentication #

	frobulator.fwd "Authenticating..."
	echo

	while read -r entry
	do
		IFS=':'

		read USER _ USER_ID GROUP_ID GECOS HOME SHELL <<< "${entry}"

		IFS=','

		read FULL_NAME ROOM_NUMBER WORK_PHONE HOME_PHONE USER_EMAIL <<< "${GECOS}"

		# reset IFS

		IFS=' '

		# verify login options and parameters

		if [[ -z "${user_name}" ]]
		then
			USER="root"

			frobulator.wrn "No user name - Defaulting" "[ '${USER}' ]"
			echo

			# break out of loop - empty "${user_name}" - default to 'root'

			break
		fi

		if [[ "${user_name}" == "${USER}" ]]
		then
			USER="${USER}"

			frobulator.scs "Valid user name" "[ '${USER}' ]"
			echo

			# break out of loop - matching "${user_name}"

			break
		fi

		if [[ "${entry}" == "${last_entry}" ]]
		then
			USER="root"

			frobulator.err "Invalid user name - Defaulting" "[ '${USER}' ]"
			echo
		fi

		# specify login defaults

		if [[ -z "${user_name}" ]] || [[ "${entry}" == "${last_entry}" ]]
		then
			USER="root"
			USER_ID="0"
			GROUP_ID="0"

			if [ -d "${ROOT}"/root ]
			then
				HOME="/root"
			else
				HOME="/"
			fi

			session_name="CONSOLE"

		fi

	done < "${ROOT}"/etc/passwd
}

container_session () {
	# set session settings

	frobulator.fwd "Starting session" "[ ${session_name} // ${user_name} ]"
	echo

	# assume 'termux-exec' is installed

	unset LD_PRELOAD

	# setup 'proot' command arguments

	unset session_command

	session_command+="proot"
	session_command+=" --kill-on-exit"
	session_command+=" --link2symlink"
	session_command+=" --rootfs=${ROOT}"
	session_command+=" --change-id=${USER_ID}:${GROUP_ID}"
	session_command+=" --pwd=${HOME}"
	[ -d "/apex" ]                                && session_command+=" --bind=/apex:/apex"
	[ -d "/data" ]                                && session_command+=" --bind=/data:/data"
	[ -d "/dev" ]                                 && session_command+=" --bind=/dev:/dev"
	[ -e "/dev/urandom" ]                         && session_command+=" --bind=/dev/urandom:/dev/random"
	[ -e "/linkerconfig/ld.config.txt" ]          && session_command+=" --bind=/linkerconfig/ld.config.txt:/linkerconfig/ld.config.txt"
	[ -f "/plat_property_contexts" ]              && session_command+=" --bind=/plat_property_contexts:/plat_property_contexts"
	[ -f "/property_contexts" ]                   && session_command+=" --bind=/property_contexts:/property_contexts"
	[ -d "/proc" ]                                && session_command+=" --bind=/proc:/proc"
	[ -d "/proc/self/fd" ]                        && session_command+=" --bind=/proc/self/fd:/dev/fd"
	[ -e "/proc/self/fd/0" ]                      && session_command+=" --bind=/proc/self/fd/0:/dev/stdin"
	[ -e "/proc/self/fd/1" ]                      && session_command+=" --bind=/proc/self/fd/1:/dev/stdout"
	[ -e "/proc/self/fd/2" ]                      && session_command+=" --bind=/proc/self/fd/2:/dev/stderr"
	[ -d "/storage" ]                             && session_command+=" --bind=/storage:/storage"
	[ -d "/sys" ]                                 && session_command+=" --bind=/sys:/sys"
	[ -d "/system" ]                              && session_command+=" --bind=/system:/system"
	[ -d "/vendor" ]                              && session_command+=" --bind=/vendor:/vendor"
	[ -d "${PREFIX%/*}"/home ]                    && session_command+=" --bind=${PREFIX%/*}/home:/home/${USER}"
	[ -d "${PREFIX}"/storage/external ]           && session_command+=" --bind=${PREFIX}/storage/external:/media/external"
	[ -d "${PREFIX}"/storage/internal ]           && session_command+=" --bind=${PREFIX}/storage/internal:/media/internal"
	[ -d "${PREFIX}"/storage/internal/Documents ] && session_command+=" --bind=${PREFIX}/storage/internal/Documents:/home/${USER}/Documents"
	[ -d "${PREFIX}"/storage/internal/Downloads ] && session_command+=" --bind=${PREFIX}/storage/internal/Downloads:/home/${USER}/Documents"
	[ -d "${PREFIX}"/storage/internal/Music ]     && session_command+=" --bind=${PREFIX}/storage/internal/Music:/home/${USER}/Music"
	[ -d "${PREFIX}"/storage/internal/Pictures ]  && session_command+=" --bind=${PREFIX}/storage/internal/Pictures:/home/${USER}/Pictures"
	[ -d "${PREFIX}"/storage/internal/Public ]    && session_command+=" --bind=${PREFIX}/storage/internal/Public:/home/${USER}/Public"
	[ -d "${PREFIX}"/storage/internal/Templates ] && session_command+=" --bind=${PREFIX}/storage/internal/Templates:/home/${USER}/Templates"
	[ -d "${PREFIX}"/storage/internal/Videos ]    && session_command+=" --bind=${PREFIX}/storage/internal/Videos:/home/${USER}/Videos"
	[ -d "${PREFIX}"/tmp ]                        && session_command+=" --bind=${PREFIX}/tmp:/tmp"
	session_command+=" env -i"
	session_command+=" ANDROID_ART_ROOT=${ANDROID_ART_ROOT}"
	session_command+=" ANDROID_DATA=${ANDROID_DATA}"
	session_command+=" ANDROID_I18N_ROOT=${ANDROID_I18N_ROOT}"
	session_command+=" ANDROID_ROOT=${ANDROID_ROOT}"
	session_command+=" ANDROID_RUNTIME_ROOT=${ANDROID_RUNTIME_ROOT}"
	session_command+=" ANDROID_TZDATA_ROOT=${ANDROID_TZDATA_ROOT}"
	session_command+=" BOOTCLASSPATH=${BOOTCLASSPATH}"
	session_command+=" DEX2OATBOOTCLASSPATH=${DEX2OATBOOTCLASSPATH}"
	session_command+=" PREFIX=${PREFIX}"
	session_command+=" COLORTERM=${COLORTERM}"
	session_command+=" DISPLAY=${DISPLAY}"
	session_command+=" HOME=${HOME}"
	session_command+=" LANG=${LANG}"
	session_command+=" LOCALHOST=${LOCALHOST}"
	session_command+=" PATH=${PATH}"
	session_command+=" SHELL=${SHELL}"
	session_command+=" TERM=${TERM}"
	session_command+=" TMPDIR=${TMPDIR}"
	session_command+=" USER=${USER}"
	session_command+=" XDG_RUNTIME_DIR=/run/user/${USER_ID}"
	session_command+=" XDG_CONFIG_DIRS=/etc/xdg"
	session_command+=" XDG_CACHE_HOME=${HOME}/.cache"
	session_command+=" XDG_CONFIG_HOME=${HOME}/.config"
	session_command+=" XDG_DATA_HOME=${HOME}/.local/share"
	session_command+=" XDG_STATE_HOME=${HOME}/.local/state"
	session_command+=" XDG_DATA_DIRS=/usr/local/share:/usr/share"
	session_command+=" XAUTHORITY=${XDG_RUNTIME_DIR}/Xauthority"
	session_command+=" ${SHELL} --login"

	# execute 'proot'

	${session_command}
}

vnc_clean () {
	if [ -d "${HOME}" ]
	then
		rm -rf "${HOME}"/.ICE*
		rm -rf "${HOME}"/.X1*
		rm -rf "${HOME}"/.Xauth*
	fi

	if [ -d "${TMPDIR}" ]
	then
		rm -rf "${TMPDIR}"/.ICE*
		rm -rf "${TMPDIR}"/.X1*
		rm -rf "${TMPDIR}"/.Xauth*
	fi
}

vnc_geometry () {
	frobulator.msg "Select geometry to start the display server"
	frobulator.msg "or input [c]ustom properties:"
	echo

	# list supported display resolutions

	monitors=(
		VGA		 0640    0480
		WVGA	 0768    0480
		SVGA	 0800    0600
		FWVGA	 0854    0480
		qHD		 0960    0540
		DVGA	 0960    0640
		WSVGA	 1024    0576
		WSVGA	 1024    0600
		XGA		 1024    0768
		XGA+	 1152    0864
		HD		 1280    0720
		WXGA	 1366    0768
		WXGA+	 1440    0900
		HD+		 1600    0900

		SXGA	 1280    1024
		SXGA+	 1400    1050
		UXGA	 1600    1200
		WSXGA+	 1680    1050
		FHD		 1920    1080
		WUXGA	 1920    1200
		DCI2K	 2048    1080
		QWXGA	 2048    1152
		QXGA	 2048    1536
		UWFHD	 2560    1080
		QHD		 2560    1440
		WQXGA	 2560    1600
		QSXGA	 2560    2048
		QHD+	 3200    1800
		WQSXGA	 3200    2048
		QUXGA	 3200    2400
		UWQHD	 3440    1440
		UW4K	 3840    1600
		4KUHD	 3840    2160
		WQUXGA	 3840    2400
		DCI4K	 4096    2160
		UW5K	 5120    2160
		5K		 5120    2880
		8KUHD	 7680    4320
	)

	phones=(
		GN6P	 2560    1440
		GN6		 2560    1440
		GN5X	 1920    1080
		GN5		 1920    1080
		GP5		 2340    1080
		GP4XL	 3040    1440
		GP4a	 2340    1080
		GP4		 2280    1080
		GP3aXL	 2160    1080
		GP3a	 2220    1080
		GP3XL	 2960    1440
		GP3		 2160    1080
		GP2XL	 2880    1440
		GP2		 1920    1080
		GPXL	 2560    1440
		GP		 1920    1080

		SGN20+	 3088    1440
		SGN20	 3200    1440
		SGN10+	 3040    1440
		SGN10	 2280    1080
		SGN9	 2960    1440
		SGN8	 2960    1440
		SGN7	 2560    1440

		SGS10+	 3040    1440
		SGS10	 3040    1440
		SGS9+	 2960    1440
		SGS9	 2960    1440
		SGS8+	 2960    1440
		SGS8	 2960    1440
		SGS7E	 2560    1440
		SGS7	 2560    1440
		SGS6E+	 2560    1440
		SGS6E	 2560    1440
		SGS6	 2560    1440
	)

	tablets=(
		GN9	     2048    1536
		GN7-2013 1920    1200
		GPC	     2560    1800

		SGTS7+	 2800    1752
		SGTS7	 2560    1600
		SGTS6	 2560    1600
		SGTS5E	 2560    1600
		)

	devices=(
		${phones[@]}
		${tablets[@]}
	)

	geometries=(
		${monitors[@]}
		${devices[@]}
	)

	# set padding for uniform output

	pad_length=10

	# continue list using array selection of suppported values

	for (( i=0 ; i<${#geometries[@]} ; i+=3 ))
	do
		format="${geometries[$i]}"
		width="${geometries[$i+1]}"
		height="${geometries[$i+2]}"
		geometry="${width}x${height}"

		number=$((($i/3) + 1))

		if (( $i/3 >= 0 && $i/3 <= 8 ))
		then
			# handle number spacing for entries 1-9

			printf '      [  %s ] %s' ${number} ${format}
		else
			# handle number spacing for entries 10+

			printf '      [ %s ] %s' ${number} ${format}
		fi

		printf '%*s' $((pad_length - ${#format}))
		printf '%s\n' ${geometry}
	done

	printf '\n'
}

vnc_handle () {
	# values #

	values_list=(
		selection
	)

	# handle user input for values_list

	frobulator_rtn=()

	if [ -f "${HOME}"/.vnc/selection ]
	then
		selection=$(cat "${HOME}"/.vnc/selection)
	else
		frobulator.input ${values_list[@]}
	fi

	eval ${frobulator_rtn[@]}

	# check selection input against selection list

	while true
	do
		# range check:
		# selection input must be in provided range and an integer

		if [[ "${selection}" -lt 1 ]] || [[ "${selection}" -gt "${number}" ]] || [[ ! "${selection}" =~ ^[0-9]+$ ]]
		then
			echo
			frobulator.err "Invalid selection:"
			echo

			frobulator.wrn "Select geometry [ 1 - ${number} ]"
			frobulator.wrn "or input [c]ustom properties."
			echo

			frobulator.ipt "Selection:"

			read selection
			echo
		else
			break
		fi

		if [[ "${selection}" = [cC] ]]
		then
			selection=custom

			break
		fi
	done

	unset geometry

	# integer check:
	# handle numerical selection

	if [[ "${selection}" =~ ^[0-9]+$ ]]
	then
		i=$((${selection}))
		i=$(($i*3))

		format="${geometries[$i-3]}"
		width="${geometries[$i-2]}"
		height="${geometries[$i-1]}"
		geometry="${width}x${height}"

	fi

	# handle custom selection

	if [[ "${selection}" = "custom" ]]
	then
		frobulator.fwd "Setting custom properties..."
		echo

		frobulator.ipt "Set width" "[ pixels ]"

		read width
		echo

		frobulator.ipt "Set height" "[ pixels ]"

		read height
		echo

		frobulator.ipt "Set display number" "[ e.g. 1 ]"

		read display
		echo

		format="Custom"
		geometry="${width}x${height}"

		DISPLAY=":${display}"
		DISPLAY_NUMBER="${DISPLAY/:/}"
		PORT="590${DISPLAY_NUMBER}"
	fi
}

vnc_intent () {
	frobulator.fwd "Opening display..."
	echo

	# explicit VNC viewer application to kill:
	# used when vncserver is stopped or restarted using vnc:// intent
	# when launched via the activity manager [ 'am start -d {URI} -S {ACTIVITY}' ]

	# reference vnc session activity for known applications:

	# FreebVNC: com.iiordanov.freebVNC/com.iiordanov.bVNC.RemoteCanvasActivity
	# RealVNC:  com.realvnc.viewer.android/.app.DesktopActivity
	# Remotix:  com.nulana.android.remotix/.Viewer

	# start android vnc intent and force-stop existing activity

	# frobulator.silence "am start -a android.intent.action.VIEW -d vnc://${ADDRESS}:${PORT} -S ${vnc_application}"

	# start android vnc intent and set to view session with supported application

	unset intent_command

	intent_command+="am start"
	intent_command+=" -a android.intent.action.VIEW"
	intent_command+=" -d vnc://${ADDRESS}:${PORT}"

	frobulator.silence "${intent_command}"
}

vnc_view () {

	vnc_application="com.nulana.android.remotix/.Viewer"

	unset intent_command

	intent_command+="am start"
	intent_command+=" -a android.intent.action.VIEW"
	intent_command+=" -d vnc://${ADDRESS}:${PORT}"
	intent_command+=" -S ${vnc_application}"

	frobulator.silence "${intent_command}"
}

vnc_framebuffer () {
	unset command_framebuffer

	command_framebuffer+="Xvfb"
	command_framebuffer+=" -screen ${DISPLAY_NUMBER}"
	command_framebuffer+=" ${geometry}x24"

	${command_framebuffer} > /dev/null 2>&1 &
#	frobulator.silence "exec ${command_framebuffer}"
}

vnc_load () {
	vnc_framebuffer

	frobulator.fwd "Starting display server..."
	echo

	depth="32"
	security="none"
	timeout="0"
	xstartup="$(echo $(command -v startxfce4 &))"

	# Notes:
	# 'vncserver' uses $DISPLAY instead of $PORT
	# use 'Xvnc' to ensure proper parameter application

	unset command_load

#	command_load+="vncserver"
#	command_load+=" -xstartup ${xstartup}"
#	command_load+=" -SecurityTypes ${security}"
#	command_load+=" -IdleTimeout ${timeout}"
#	command_load+=" -depth ${depth}"
#	command_load+=" -geometry ${geometry}"
#	command_load+=" -desktop ${name}"
#	command_load+=" -nolock"
#	command_load+=" ${DISPLAY}"

	command_load+="x11vnc"
	command_load+=" -display ${DISPLAY}"
	command_load+=" -clip xinerama=${DISPLAY}"
	command_load+=" -xkb"
	command_load+=" -noxdamage"
	command_load+=" -noxrecord"
	command_load+=" -noxfixes"
	command_load+=" -noshm"
	command_load+=" -scale 1.00"
	command_load+=" -rfbport ${PORT}"

	${command_load} > /dev/null 2>&1 &
#	frobulator.silence "exec ${command_load}"

	# make selection available for automatic start:
	# verify user id - do not write selection when 'root' user is logged in

	if [[ $(id -u -n) = "root" ]]
	then
		:
	else
		# integer check:
		# do not write non numerical values to file

		if [[ "${selection}" =~ ^[0-9]+$ ]]
		then
			echo "${selection}" > "${HOME}"/.vnc/selection
			echo "${format}"    > "${HOME}"/.vnc/format
			echo "${geometry}"  > "${HOME}"/.vnc/geometry
		fi
	fi

	vnc_intent
}

vnc_start () {
	if [[ $(pidof Xvnc) ]]
	then
		:
	else
		# handle selections display

		if [ -f "${HOME}"/.vnc/selection ]
		then
			# hide if selection file is present

			vnc_geometry > /dev/null 2>&1
		else
			# show if selection file is not present

			vnc_geometry
		fi

		# handle vnc selections

		vnc_handle

		# start vnc session

		vnc_load
	fi
}

vnc_new () {
	# handle selections display

	if [ -f "${HOME}"/.vnc/selection ]
	then
		# remove if selection file is present

		rm -rf  "${HOME}"/.vnc/selection
	fi

	# show display format selections

	vnc_geometry

	# handle vnc selections

	vnc_handle

	# start vnc session

	vnc_load
}

vnc_stop () {
	unset command_stop

	command_stop+="vncserver"
	command_stop+=" -kill ${DISPLAY}"

	frobulator.silence "exec ${command_stop}" &

	frobulator.progress "Stopping display server..."
	echo

	# clean display server runtime files

	vnc_clean
}

vnc_list () {
	vnc_format=$(cat "${HOME}"/.vnc/format)
	vnc_geometry=$(cat "${HOME}"/.vnc/geometry)

	if [[ $(pidof proot) ]]
	then
		read vnc_display _ vnc_process _ <<< $(vncserver -list | tail -n 1)
	else
		read vnc_display vnc_process <<< $(vncserver -list | tail -n 1)
	fi

	vnc_port="${PORT}"

	if [[ $(pidof Xvnc) ]] || [[ $(pidof Xtigervnc) ]]
	then
		frobulator.fwd "Listing servers..."
		echo

		vnc_format="${vnc_format}"
		vnc_geometry="${vnc_geometry}"
		vnc_display="${vnc_display}"
		vnc_process="${vnc_process}"
		vnc_port="${vnc_port}"
	else
		frobulator.wrn "No active servers detected."
		echo

		empty="N/A"

		vnc_format="${empty}"
		vnc_geometry="${empty}"
		vnc_display="${empty}"
		vnc_process="${empty}"
		vnc_port="${empty}"
	fi

	frobulator.inf "Format"   "[ ${vnc_format} ]"
	frobulator.inf "Geometry" "[ ${vnc_geometry} ]"
	frobulator.inf "Display"  "[ ${vnc_display} ]"
	frobulator.inf "Process"  "[ ${vnc_process} ]"
	frobulator.inf "Port"     "[ ${vnc_port} ]"
	echo
}

vnc_password () {
	# values #

	values_list=(
		vnc_password
	)

	# handle user input for values_list

	frobulator_rtn=()

	frobulator.input ${values_list[@]}

	eval ${frobulator_rtn[@]}

	# hash password  using 'vncpasswd' and store it

	frobulator.fwd "Setting password..."
	echo

	echo "$vnc_password" | vncpasswd -f > "${HOME}"/.vnc/passwd

	frobulator.scs "Password changed."
	echo
}

application_handle () {
	# handle application launch

	if [[ $(command -v "${application}") ]]
	then
		${application} &
	else
		frobulator.err "Application not found" "[ "${application}" ]"
		echo

		if [[ $(command -v zenity) ]]
		then
			zenity			 											\
				--warning												\
					--width="200"										\
					--window-icon="${HOME}/.dextop/dextop.svg"	\
					--text="Application '${application}' not found." 2> /dev/null &
		fi
	fi
}

if [ "${option}" = "start" ]
then
	# start vnc session

	vnc_start
fi

if [ "${option}" = "stop" ]
then
	# stop vnc session

	vnc_stop
fi

if [ "${option}" = "password" ]
then
	# generate password

	vnc_password
fi

if [ "${option}" = "clean" ]
then
	# remove lock files and session handlers

	vnc_clean
fi

if [ "${option}" = "new" ]
then
	# start vnc session with new selection

	vnc_new
fi

if [ "${option}" = "view" ]
then
	# reload vnc viewer application window:
	# some activity launches are buggy

	vnc_view
fi

if [ "${option}" = "application" ]
then
	# validate and start application

	application_handle
fi

if [ "${option}" = "username" ]
then
	# validate root filesystem

	container_root

	# set environemnt

	container_environment

	# validate username

	container_user

	# start container session

	container_session
fi

if [ "${option}" = "root" ]
then
	# handle manual container location input

	container_input

	# validate root filesystem

	container_root

	# set environemnt

	container_environment

	# validate username

	container_user

	# start container session

	container_session
fi

# list vnc session

vnc_list
