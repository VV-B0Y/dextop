#!/bin/bash

# dependencies /////////////////////////////////////////////////////////////////

[[ -z $(command -v frobulator) ]] && curl -s -L get.frbltr.app > "${PREFIX}"/bin/frobulator

. "${PREFIX}"/bin/frobulator

# script ///////////////////////////////////////////////////////////////////////

script=$(basename -- "${BASH_SOURCE[0]}")

# version //////////////////////////////////////////////////////////////////////

version="01-21-2022"

# usage ////////////////////////////////////////////////////////////////////////

while (($#))
do
	case "${1}"
	in
		-i|--image)
			option="image"
			distribution_name="${2}"

			shift

			distribution_version="${2}"

			shift
		;;

		-s|--selection)
			option="selection"
		;;

		-h|--help)
			echo
			echo -e "Usage: ${script} -i [Distribution Name] [Distribution Version] | [OPTION]"
			echo
			echo -e "Options:"
			echo
			echo -e "-i, --image        Input distribution name and version."
			echo -e "-s, --selection    Show setup selection options."
			echo
			echo -e "-h, --help     Show help and usage information."
			echo
			echo -e "'${script}' [ Version // ${version} ]"
			echo

			exit
		;;

			"")
				# handle empty argument:
				# use default values specified in script

				:
			;;

		*)
			echo
			echo -e "Usage: ${script} -i [Distribution Name] [Distribution Version] | [OPTION]"
			echo
			echo -e "${script}: Unknown option '${1}'"
			echo -e "Type './${script} --help' for help and usage information."
			echo

			exit 1
		;;

	esac

	shift
done

# prompt ///////////////////////////////////////////////////////////////////////

frobulate.script "Setting up ${script#*-}"
echo

# variables ////////////////////////////////////////////////////////////////////

# defaults /////////////////////////////////////////////////////////////////////

[ -z "${distribution_name}" ] && distribution_name="ubuntu"
[ -z "${distribution_version}" ] && distribution_version="21.10"

# functions ////////////////////////////////////////////////////////////////////

image_version () {
	# list distributions for setup

	if [ -z "${distribution_name}" ] || [ -z "${distribution_version}" ]
	then
		frobulate.msg "Select distribution version to setup."
		echo

		# list supported distribution versions

		fedora_versions=(
			fedora	33
			fedora	34
			fedora	35
		)

		ubuntu_versions=(
			ubuntu	20.04.3
			ubuntu	21.04
			ubuntu	21.10
		)

		versions=(
		#	${fedora_versions[@]}
			${ubuntu_versions[@]}
		)

		# set padding for uniform output

		pad_length=10

		# continue list using array selection of suppported values

		for (( i=0 ; i<${#versions[@]} ; i+=2 ))
		do
			name="${versions[$i]}"
			version="${versions[$i+1]}"

			number=$((($i/2) + 1))

			if (( $i/2 >= 0 && $i/2 <= 8 ))
			then
					# handle number spacing for entries 1-9

					printf '      [  %s ] %s %s' ${number} ${name}
			else
					# handle number spacing for entries 10+

					printf '      [ %s ] %s %s' ${number} ${name}
			fi

			printf '%*s' $((pad_length - ${#name}))
			printf '%s\n' ${version}
		done

		printf '\n'

		# values #

		values_list=(
			selection
		)

		# handle user input for values_list

		eval ${frobulate.rtn[@]}

		frobulate.ipt "Selection:"

		read selection
		echo

		unset distribution_version

		# integer check:
		# handle numerical selection

		if [[ "${selection}" =~ ^[0-9]+$ ]]
		then
			i=$((${selection}))
			i=$(($i*2))

			version="${versions[i-1]}"
			name="${versions[i-2]}"

			distribution_name="${name}"
			distribution_version="${version}"
		fi

		# handle distribution code markup

		if [ "${distribution_name}" = ubuntu ]
		then
			# set IFS

			IFS='.'

			read code_year code_month code_revision <<< "${distribution_version}"

			if [ -z "${code_revision}" ]
			then
				distribution_release="${distribution_version}"
			else
				distribution_release="${distribution_version%.*}"
			fi

			# reset IFS

			IFS=''
		fi

		export distribution_name="${distribution_name}"
		export distribution_release="${distribution_release}"
		export distribution_version="${distribution_version}"
	fi
}

image_architecture () {
	#compare system architecture to available image architectures

	cpu_architectures=(
		aarch64
		arm
		amd64
		i*86
		x86_64
	)

	# list supported image architechtures

	if [ "${distribution_name}" = fedora ]
	then
		image_architectures=(
		aarch64
		armhfp
		x86_64
		x86_64
		x86_64
		)
	fi

	if [ "${distribution_name}" = ubuntu ]
	then
		image_architectures=(
		arm64
		armhf
		amd64
		i386
		amd64
		)
	fi

	# test processor architecture string

	device_architecture="$(uname -m)"

	for i in ${!cpu_architectures[@]}
	do
		if [[ "${device_architecture}" == "${cpu_architectures[i]}" ]]
		then
			image_architecture=${image_architectures[i]}

			frobulate.scs "Supported architecture" "[ ${image_architecture} ]"
			echo

			break
		else
			frobulate.wrn "Unsupported architecture" "[ ${image_architecture} ]"
			echo

			frobulate.fwd "Aborting..."
			echo

			frobulate.stp "Exiting."
			echo

			exit 1
		fi
	done

	# test image architecture string

	if [ -z "$image_architecture" ] || [ -z "${device_architecture}" ]
	then
		image_architecture="N/A"

		frobulate.wrn "Unknown architecture" "[ ${image_architecture} ]"
		echo

		frobulate.fwd "Aborting..."
		echo

		frobulate.stp "Exiting."
		echo

		exit 1
	fi
}

image_download () {
	# generate links and download distribution image

	# handle distribution url

	case "${distribution_name}"
	in
		fedora)
			image_url="https://download.fedoraproject.org/pub/fedora/linux/releases/${distribution_version}/Container/${image_architecture}/images"
			image_archive="Fedora-Container-Base-${distribution_version}-1.2.${image_architecture}.tar.xz"
			image_name="${distribution_name}-${distribution_version}"
			image_file="${image_name}.tar.gz"
		;;

		ubuntu)
			image_url="http://cdimage.ubuntu.com/ubuntu-base/releases/${distribution_version}/release"
			image_archive="ubuntu-base-${distribution_version}-base-${image_architecture}.tar.gz"
			image_name="${distribution_name}-${distribution_version}"
			image_file="${image_name}.tar.gz"
		;;
	esac

	frobulate.download "${image_url}"/"${image_archive}" "${PREFIX}"/img "${image_file}"
}

image_extract () {
	# exclude archive directories: dev | proc | sys | system
	# 'container-session' will bind those device directories to the container

	container_extract () {
		# cloud container/docker images

		tar 									\
			--extract							\
			--delay-directory-restore			\
			--preserve-permissions				\
				--file="${1}"					\
						--strip-components='1'	\
						--exclude='VERSION'		\
						--exclude='json'		\
						--exclude='boot'		\
						--exclude='dev'			\
						--exclude='proc'		\
						--exclude='sys'			\
						--exclude='system' 		\
							--directory="${2}" 2> /dev/null
	}

	core_extract () {
		# core/minimal system images

		proot											\
			--link2symlink								\
				tar 									\
					--extract							\
					--delay-directory-restore			\
					--preserve-permissions				\
						--file="${1}"					\
								--exclude='boot'		\
								--exclude='dev'			\
								--exclude='proc'		\
								--exclude='sys'			\
								--exclude='system'		\
									--directory="${2}" 2> /dev/null

	}

	frobulate.wrn "Extracting new deployment" "[ ${image_file} // ${image_architecture} ]"
	echo

	frobulate.directory "${PREFIX}"/cnt "${distribution_name}"/"${distribution_version}"

	if [ "${distribution_name}" = fedora ]
	then
		container_extract "${PREFIX}"/img/"${image_file}" "${PREFIX}"/img

		mv "${PREFIX}"/img/layer.tar "${PREFIX}"/img/"${image_name}.tar"

		core_extract "${PREFIX}"/img/"${image_name}.tar" "${PREFIX}"/cnt/"${distribution_name}"/"${distribution_version}"
	fi

	if [ "${distribution_name}" = ubuntu ]
	then
		core_extract "${PREFIX}"/img/"${image_file}" "${PREFIX}"/cnt/"${distribution_name}"/"${distribution_version}"
	fi
}

image_handle () {
	# set container image name and version

	case "${distribution_name}"
	in
		[uU][bB][uU][nN][tT][uU])
			distribution_name="${distribution_name,,}"

			frobulate.scs "Supported distribution name."
			echo
		;;

		[fF][eE][dD][oO][rR][aA])
			distribution_name="${distribution_name,,}"

			frobulate.scs "Supported distribution name."
			echo
		;;

		"")
			distribution_name="ubuntu"

			frobulate.err "Empty distribution name."
			echo
		;;


		*)
			distribution_name="ubuntu"

			frobulate.err "Unsupported distribution name."
			echo

			frobulate.wrn "Defaulting" "[ ${distribution_name} ]"
			echo
		;;
	esac

	if [ "${distribution_name}" = "ubuntu" ]
	then
		case "${distribution_version}"
		in
			20*04|20*04*)
				distribution_version="20.04.3"

				frobulate.scs "Supported distribution version."
				echo
			;;

			21*04|21*04*)
				distribution_version=21.04

				frobulate.scs "Supported distribution version."
				echo
			;;

			21*10|20*10*)
				distribution_version=21.10

				frobulate.scs "Supported distribution version."
				echo
			 ;;

			"")
				distribution_version=21.10

				frobulate.err "Empty distribution version."
				echo
			;;

			 *)
				distribution_version=21.10

				frobulate.err "Unsupported distribution version."
				echo

				frobulate.wrn "Defaulting" "[ ${distribution_version} ]"
				echo
			;;
		esac
	fi

	if [ "${distribution_name}" = "fedora" ]
	then
		case "${distribution_version}"
		in
			33)
				distribution_version=33
			;;

			34)
				distribution_version=34
			;;

			35)
				distribution_version=35
			 ;;

			 "")
				distribution_version=35

				frobulate.err "Empty distribution version."
				echo
			;;


			 *)
				distribution_version=35

				frobulate.err "Unsupported distribution version"
				echo

				frobulate.wrn "Defaulting" "[ ${distribution_version} ]"
				echo
			;;
		esac
	fi
}

image_environment () {
	# generate environment '$PATH'

	# set path:
	# in order of retreival

	PATH=""

	# container

	[ -d "${PREFIX}"/cnt/"${distribution_name}"/"${distribution_version}"/usr/local/sbin ] && PATH+="/usr/local/sbin:"
	[ -d "${PREFIX}"/cnt/"${distribution_name}"/"${distribution_version}"/usr/local/bin ]  && PATH+="/usr/local/bin:"
	[ -d "${PREFIX}"/cnt/"${distribution_name}"/"${distribution_version}"/usr/sbin ]       && PATH+="/usr/sbin:"
	[ -d "${PREFIX}"/cnt/"${distribution_name}"/"${distribution_version}"/usr/sbin ]       && PATH+="/usr/bin:"
	[ -d "${PREFIX}"/cnt/"${distribution_name}"/"${distribution_version}"/sbin ]           && PATH+="/sbin:"
	[ -d "${PREFIX}"/cnt/"${distribution_name}"/"${distribution_version}"/bin ]            && PATH+="/bin:"

	# termux

	[ -d "${PREFIX}"/sbin ]               && PATH+="${PREFIX}/sbin:"
	[ -d "${PREFIX}"/bin ]                && PATH+="${PREFIX}/bin:"

	# android

	[ -d /system/sbin ]                   && PATH+="/system/sbin:"
	[ -d /system/bin ]                    && PATH+="/system/bin:"

	# set environment

	PATH="${PATH}"

	cat <<- FILE > "${PREFIX}"/cnt/"${distribution_name}"/"${distribution_version}"/etc/environment
	PREFIX=${PREFIX}
	PATH=${PATH}
	FILE
}

image_groups () {
	# register android groups to container

	# set IFS

	IFS=' '

	# read android system IDs

	read uid gid groups <<< $(id)

	uid=${uid/uid=}
	gid=${gid/gid=}
	groups=${groups/groups=}

	# set IFS

	IFS=','

	# parse existing groups

	read -r -a groups_list <<< "${groups}"

	for line in "${groups_list[@]}"
	do
		line=${line/(/ }
		line=${line/)}

		# set IFS

		IFS=' '

		# transfer unregistered IDs

		read group_number group_name <<< ${line}

		[ -f "${PREFIX}"/cnt/"${distribution_name}"/"${distribution_version}"/etc/group ]   && echo "${group_name}:x:${group_number}:" >> "${PREFIX}"/cnt/"${distribution_name}"/"${distribution_version}"/etc/group
		[ -f "${PREFIX}"/cnt/"${distribution_name}"/"${distribution_version}"/etc/gshadow ] && echo "${group_name}:x:${group_number}:" >> "${PREFIX}"/cnt/"${distribution_name}"/"${distribution_version}"/etc/gshadow

	done

	# reset IFS

	IFS=''
}

image_network () {
	# generate network files

	# hostname

	cat <<- 'FILE' > "${PREFIX}"/cnt/"${distribution_name}"/"${distribution_version}"/etc/hostname
	${HOSTNAME}
	FILE

	# hosts

	cat <<- 'FILE' > "${PREFIX}"/cnt/"${distribution_name}"/"${distribution_version}"/etc/hosts
	# IPv4 #

	127.0.0.1	localhost.localdomain
	127.0.0.1	localhost

	# IPv6 #

	::1			localhost.localdomain
	::1			localhost
	::1			ip6-localhost
	::1			ip6-loopbak
	fe00::0		ip6-localnet
	fe00::0		ip6-mcastprefix
	ff02::1		ip6-allnodes
	ff02::2		ip6-allrouters
	ff02::3		ip6-allhosts
	FILE

	# nameserver

	cat <<- 'FILE' > "${PREFIX}"/cnt/"${distribution_name}"/"${distribution_version}"/etc/resolv.conf
	nameserver 1.1.1.1
	nameserver 1.0.0.1
	FILE
}
image_preload () {
	# generate libgcc/libc location and add to dynamic linker for preload

	preload_library=$(find "${PREFIX}"/cnt/"${distribution_name}"/"${distribution_version}"/usr/lib -type f -iname "libgcc_s.so.1")

	# set preload

	cat <<- FILE > "${PREFIX}"/cnt/"${distribution_name}"/"${distribution_version}"/etc/ld.so.preload
	${preload_library}
	FILE
}

if [ "${option}" = "image" ]
then
	# validate distribution name and version

	image_handle
fi

if [ "${option}" = "selection" ]
then
	unset distribution_name
	unset distribution_version

	# select image version

	image_version
fi

# verify architecture

image_architecture

# download image

image_download

# extract image into container directory

image_extract

# generate environment variables

image_environment

# generate missing groups

image_groups

# generate network

image_network

# generate preload entries

image_preload
